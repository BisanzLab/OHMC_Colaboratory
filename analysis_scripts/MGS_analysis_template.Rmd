---
title: "MGS Analysis Template"
author: Your name here
date: '`r format(Sys.time(), "%Y-%m-%d %H:%M")`'
output: 
  html_document:
    code_folding: show
    theme: cerulean
    number_sections: true
    highlight: monochrome
    fig_width: 7
    fig_height: 4
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---

  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=F)
```




# Background

## Purpose

Information describing the experiment and the goals for analysis here.

Note: This template is for simple cross sectional analyses, but contains the code for importing and processing any study design. See also the inclusion of a parallel function for linear mixed effects models for more complex study designs.

## Experimental Methods

Information on how samples were prepared and sequenced here. For Example if using standard lab workflow:

gDNA was extracted from fecal pellets using a DNeasy 96 PowerSoil Pro QIAcube HT Kit with liquid handling performed by a Integra mini-96 1250µL multichannel and a QIAcube HTP extraction platform. Samples were normalized to 6 ng/µL with 6 µL was used as the input to a 1/5th scale Illumina DNA Prep protocol using unique dual indexes based on the Illumina Tagmentation Set A-D. The resulting library was balanced using an Illumina iSeq100 2x150 run before full sequencing on a paired-end 150 NovaSeq X 25B lane (Novogene USA). Samples were sequenced with 43,196,663±5,747,337 (mean±sd) reads. Strain abundances were determined using StrainR2 with default parameters as previously described (22). All input strains were detected in the input community administered to mice.


## Version/change log

- 1 Aug 2025 - Version 0.1 ready for sharing

## Notes

***

# User parameters

```{r}
indir<-"/data/SequencingRuns/2025May05_MGS2/tmp_output/output" # directory with mgs pipeline output it in
prefix<-"SLSD" #only pull samples with this sample prefix (for mixed runs). Could set to * to be any sample in this directory
metadatafile<-"LSD_metadata.xlsx" # must have column SampleID and Group at minimum
```


***
  
# R Setup

## Libraries
  
Load your libraries here. Version information for writing manuscripts will be included below:
  
```{r}
library(tidyverse)
library(readxl)
library(qiime2R)
library(vegan)
library(multidplyr)
library(parallel)
library(lmerTest)

dir.create("figures") # this will create a folder for figures/output that might be necessary
dir.create("processed_data")
theme_set(theme_q2r()) # this will ensure that figures are stored with appropriate fonts/aesthetics
sessionInfo()
```

## Citation Information

This will be automatically generated based on the libraries loaded.

```{r}
packages_in_use <- c( sessionInfo()$basePkgs, names( sessionInfo()$loadedOnly ) )
lapply( X=packages_in_use, FUN=citation) %>%
  print()
```

***

## Parallel Differential Abundance Functions

These will be used to speed up large differential abundance calculations. There is some overhead in forking the processes so this would be best used for thousands of independent features (ex genes). Assumes data have been properly normalized (ex CLR or log TSS). Note: fold changes assume data was log transformed!

```{r}
DoParallel_ttest<-function(data, nthreads, featureid, groupid, abundanceid){
  #data is a data table in long format
  #nthreads is number of processes
  #featureid is the column name of gene/taxa/etc
  #groupid is the column name for the variable to test in the t test
  #abundanceid is the column name for the abundance column to be tested
  
  #Ex usage:
      #tmptest<-
      #GeneAbundances_filled %>%
      #  left_join(metadata) %>%
      #  DoParallel_ttest(., 10, "GeneFamily","Group","log2RPKG")
        
  message(paste("Starting at ", date()))
  if(missing(data)){message(stop("input data table not provided"))}
  if(missing(nthreads)){message(stop("number of parallel processes must be provided"))}
  if(missing(featureid)){message(stop("name of feature ids must be provided"))}
  if(missing(groupid)){message(stop("name of group ids must be provided"))}
  if(missing(abundanceid)){message(stop("name of the abundance column must be provided"))}

  clus<-new_cluster(nthreads) # eastablish cluster
  cluster_library(clus, "dplyr") # load any required packages
  
  diff_abun<-
  data %>%
  dplyr::rename(GROUP=all_of(groupid)) %>%
  dplyr::rename(FEATURE=all_of(featureid)) %>%
  dplyr::rename(ABUNDANCE=all_of(abundanceid)) %>%
  group_by(FEATURE) %>%
  partition(clus) %>%
  do({
         results=t.test(ABUNDANCE ~ GROUP, data = .)
         result_table=as.data.frame(as.matrix(results$estimate) %>% t())
         result_table$CI95Low=results$conf.int[1]
         result_table$CI95High=results$conf.int[1]
         result_table$Pvalue=results$p.value
         result_table$FEATURE=.$FEATURE[1] 
         result_table
  }) %>% 
  collect() %>% 
  ungroup()

rm(clus)
gc()
#ps::ps_children() #ensure cluster shut down

diff_abun<-diff_abun %>% 
  mutate(log2FC=.[[1]]-.[[2]]) %>%
  select(!!featureid:=FEATURE, log2FC, everything()) %>% 
  mutate(FDR=p.adjust(Pvalue, method="BH"))

message(paste("Finished at ", date())) # approx 26 sec for 250,000 features
message(message("Note: fold change calculations assume that data was log2 transformed or CLR transformed with a log2 base")) # approx 26 sec for 250,000 features

return(diff_abun)
}

##############################################################################################################
##############################################################################################################
##############################################################################################################

  
DoParallel_wilcox<-function(df, nthreads, featureid, groupid, abundanceid){
  #data is a data table in long format
  #nthreads is number of processes
  #featureid is the column name of gene/taxa/etc
  #groupid is the column name for the variable to test in the t test
  #abundanceid is the column name for the abundance column to be tested
  
  #Ex usage:
    #DiffTaxa<-
    #  TaxTable %>%
    #  left_join(metadata) %>%
    #  DoParallel_wilcox(., 4, "Taxon", "Group", "log2Abundance")
            
  message(paste("Starting at ", date()))
  if(missing(df)){message(stop("input data table not provided"))}
  if(missing(nthreads)){message(stop("number of parallel processes must be provided"))}
  if(missing(featureid)){message(stop("name of feature ids must be provided"))}
  if(missing(groupid)){message(stop("name of group ids must be provided"))}
  if(missing(abundanceid)){message(stop("name of the abundance column must be provided"))}

  clus<-new_cluster(nthreads) # eastablish cluster
  cluster_library(clus, c("dplyr", "tidyr")) # load any required packages
  
  diff_abun<-
  df %>%
  dplyr::rename(GROUP=all_of(groupid)) %>%
  dplyr::rename(FEATURE=all_of(featureid)) %>%
  dplyr::rename(ABUNDANCE=all_of(abundanceid)) %>%
  group_by(FEATURE) %>%
  partition(clus) %>%
  do({
         tmptbl<-.
         results=wilcox.test(ABUNDANCE ~ GROUP, data = tmptbl)
         result_table<-tmptbl %>% group_by(GROUP) %>% summarize_at("ABUNDANCE", lst(mean,median)) %>% pivot_longer(!GROUP) %>% unite("METRIC", name, GROUP, sep="_") %>% arrange(METRIC) %>% pivot_wider(names_from = METRIC) 
         result_table$Pvalue=results$p.value
         result_table$FEATURE=tmptbl$FEATURE[1] 
         result_table
  }) %>% 
  collect() %>% 
  ungroup()

rm(clus)
gc()
#ps::ps_children() #ensure cluster shut down

diff_abun<-diff_abun %>% 
  mutate(log2FC=.[[1]]-.[[2]]) %>%
  select(!!featureid:=FEATURE, log2FC, everything()) %>% 
  mutate(FDR=p.adjust(Pvalue, method="BH"))

message(paste("Finished at ", date())) # approx 26 sec for 250,000 features
message(message("Note: fold change calculations assume that data was log2 transformed or CLR transformed with a log2 base")) # approx 26 sec for 250,000 features

return(diff_abun)
}

##############################################################################################################
##############################################################################################################
##############################################################################################################
  
DoParallel_lmer<-function(df, nthreads, featureid, lmerformula){
  message(paste("Starting at ", date()))
  if(missing(df)){message(stop("input data table not provided"))}
  if(missing(nthreads)){message(stop("number of parallel processes must be provided"))}
  if(missing(featureid)){message(stop("name of feature ids must be provided"))}
  if(missing(lmerformula)){message(stop("formula for model not provided, all terms in formula must be columns in table"))}

  clus<-new_cluster(nthreads) # eastablish cluster
  cluster_library(clus, c("dplyr", "tidyr", "tibble","lmerTest")) # load any required packages
  cluster_assign(clus, lmerformula=lmerformula)
  
  diff_abun<-
  df %>%
  dplyr::rename(FEATURE=all_of(featureid)) %>%
  group_by(FEATURE) %>%
  partition(clus) %>%
  do({
         tmptbl<-.
         fit<-lmer(lmerformula, data=tmptbl)
         if(isSingular(fit)){
          result_table<-data.frame(FEATURE=tmptbl$FEATURE[1], Notes="Singular Fit - model not appropriate")
          }else{
           result_table<-
                summary(fit)$coefficients %>% 
                as.data.frame() %>% 
                rownames_to_column("Term") %>% 
                mutate(FEATURE=tmptbl$FEATURE[1]) %>%
                mutate(AIC=AIC(fit)) %>%
                mutate(Notes=NA) %>%
                select(FEATURE, AIC, Term, Estimate, SE=`Std. Error`, df, Pvalue=`Pr(>|t|)`)
          }
         result_table
  }) %>% 
  collect() %>% 
  ungroup()

rm(clus)
gc()
#ps::ps_children() #ensure cluster shut down

diff_abun<-
  diff_abun %>%
  group_by(Term) %>%
  mutate(FDR=p.adjust(Pvalue, method="BH")) %>%
  ungroup()  %>%
  dplyr::rename(!!featureid:=FEATURE)

message(paste("Finished at ", date())) # approx 26 sec for 250,000 features
message(message("Note: fold change calculations assume that data was log2 transformed or CLR transformed with a log2 base")) # approx 26 sec for 250,000 features

return(diff_abun)
}

```

***

# Data Import

## Metadata
  
```{r}
metadata<-read_excel(metadatafile) # Should contain at least two columns, SampleID with names matching the SampleIDs in the file names, and Group which describes at least one experimental variable.
interactive_table(metadata)
```

## Normalizers

These values are useful for normalizing data. Note: reads/bases reported here are post-fastP QC reads rather than the raw number of reads from sequencer.

```{r}
normalizers<-
  list.files(paste0(indir, "/microbecensus/"), pattern="\\microbecensus$", full.names=TRUE) %>%
  grep(prefix, ., value=TRUE) %>%
  lapply(function(x) read_delim(x, skip=10, delim=":\t", col_names = c("Metric","Value")) %>% mutate(SampleID=basename(x) %>% gsub("\\.microbecensus","", .))) %>%
  bind_rows() %>%
  pivot_wider(names_from = Metric, values_from = Value) %>%
  dplyr::select(SampleID, AverageGenomeSize=average_genome_size, TotalBases=total_bases, GenomeEquivalents=genome_equivalents) %>%
  left_join(
    list.files(paste0(indir, "/metaphlan/"), pattern="\\.metaphlan$", full.names=TRUE) %>% 
      lapply(function(x) readLines(x)[3] %>% tibble(SampleID=basename(x) %>% gsub("\\.metaphlan$","", .), Reads=.)) %>%
      bind_rows() %>%
      mutate(Reads=gsub(" reads processed","", Reads) %>% gsub("#","", .) %>% as.numeric())
  )

interactive_table(normalizers)
write_tsv(normalizers,"processed_data/normalizers.tsv")
```

## Taxonomic Abundances

```{r}
Taxa<-list.files(paste0(indir, "/metaphlan/"), pattern="\\.metaphlan$", full.names=TRUE) %>% 
  grep(prefix, ., value=TRUE) %>%
  lapply(function(x) read_tsv(x, skip=4) %>% mutate(SampleID=basename(x) %>% gsub("\\.metaphlan$","", .)))

Taxa<-
  lapply(Taxa, function(x){
    x %>% 
      mutate(tmp=gsub("..+\\|","", `#clade_name`) %>% gsub("__..+","", .)) %>%
      mutate(TaxLevel=case_when(
        tmp=="UNCLASSIFIED"~"Unclassified",
        tmp=="k"~"Kingdom",
        tmp=="p"~"Phylum",
        tmp=="c"~"Class",
        tmp=="o"~"Order",
        tmp=="f"~"Family",
        tmp=="g"~"Genus",
        tmp=="s"~"Species",
        tmp=="t"~"Subspecies",
      )) %>%
      dplyr::select(SampleID, TaxLevel, Taxon=`#clade_name`, Relative_Abundance=relative_abundance) %>%
      group_by(TaxLevel) %>%
      mutate(Relative_Abundance_NoUnassigned=Relative_Abundance/sum(Relative_Abundance)*100) %>%
      ungroup()
  })

Taxa<-bind_rows(Taxa)

interactive_table(Taxa)
write_tsv(Taxa, "processed_data/TAXA_abundances.tsv")
```


## Gene Abundances

```{r}
GeneAbundances<-
  list.files(paste0(indir, "/humann/"), pattern="genefamilies\\.tsv$", full.names=TRUE) %>% 
  grep(prefix, ., value=TRUE) %>%
  lapply(function(x){ read_tsv(x) %>% 
      mutate(SampleID=basename(x) %>% gsub("_genefamilies\\.tsv$","", .)) %>%
      mutate(Type=if_else(grepl("\\|", `# Gene Family`), "Stratified","Unstratified")) %>%
      dplyr::select(SampleID, GeneFamily=`# Gene Family`, Type, RPK=2)
  })

GeneAbundances<-bind_rows(GeneAbundances)

GeneAbundances<-
  GeneAbundances %>%
  left_join(normalizers %>% dplyr::select(SampleID, Reads, GenomeEquivalents)) %>%
  mutate(RPKG=RPK/GenomeEquivalents, RPKM=RPK/(Reads/1e6)) %>%
  dplyr::select(-Reads, -GenomeEquivalents)

#interactive_table(GeneAbundances) # too large to embed
write_tsv(GeneAbundances, "processed_data/GENE_abundances.tsv")
```

## Pathway Abundances

```{r}
PathwayAbundances<-
  list.files(paste0(indir, "/humann/"), pattern="pathabundance\\.tsv$", full.names=TRUE) %>% 
  grep(prefix, ., value=TRUE) %>%
  lapply(function(x){ read_tsv(x) %>% 
      mutate(SampleID=basename(x) %>% gsub("_pathabundance\\.tsv$","", .)) %>%
      mutate(Type=if_else(grepl("\\|", `# Pathway`), "Stratified","Unstratified")) %>%
      dplyr::select(SampleID, Pathway=`# Pathway`, Type, Abundance=2) %>%
      filter(Pathway!="UNMAPPED" & !grepl("UNINTEGRATED", Pathway)) %>%
      group_by(Type) %>%
      mutate(Relative_Abundance=Abundance/sum(Abundance)*100) %>%
      ungroup()
  })

PathwayAbundances<-bind_rows(PathwayAbundances)

#interactive_table(PathwayAbundances) # too large to embed
write_tsv(PathwayAbundances, "processed_data/PATHWAY_abundances.tsv")
```


***
  
# Exploratory Data Analysis
  
***

## TAXA

### Taxonomic Composition
  
```{r fig.height=7, fig.width=11}
TaxTable<-
  Taxa %>%
  ungroup() %>%
  filter(TaxLevel=="Class") %>%
  dplyr::select(SampleID, Taxon, Relative_Abundance) %>%
  pivot_wider(names_from = "SampleID", values_from = "Relative_Abundance", values_fill = 0) %>%
  column_to_rownames("Taxon")

taxa_barplot(TaxTable, metadata, "Group")
ggsave("figures/TAXA_barplot.pdf", height=7.5, width=10, useDingbats=F)

TaxTable<-
  Taxa %>%
  ungroup() %>%
  filter(TaxLevel=="Species") %>%
  dplyr::select(SampleID, Taxon, Relative_Abundance) %>%
  pivot_wider(names_from = "SampleID", values_from = "Relative_Abundance", values_fill = 0) %>%
  column_to_rownames("Taxon")

taxa_heatmap(TaxTable, metadata, "Group")
ggsave("figures/TAXA_heatmap.pdf", height=7.5, width=10, useDingbats=F)
```

### Taxa Diversity

```{r}
TaxTable<-
  Taxa %>%
  ungroup() %>%
  filter(TaxLevel=="Species") %>%
  dplyr::select(SampleID, Taxon, Relative_Abundance) %>%
  pivot_wider(names_from = "SampleID", values_from = "Relative_Abundance", values_fill = 0) %>%
  column_to_rownames("Taxon")

AlphaDiversity<-
  data.frame(Shannon=vegan::diversity(TaxTable, "shannon", MARGIN=2)) %>% rownames_to_column("SampleID") %>%
  left_join(
    data.frame(Simpson=vegan::diversity(TaxTable, "simpson", MARGIN=2)) %>% rownames_to_column("SampleID")
  ) %>%
  left_join(
    data.frame(ObservedTaxa=vegan::specnumber(TaxTable, MARGIN=2)) %>% rownames_to_column("SampleID")
  )

interactive_table(AlphaDiversity)
write_tsv(AlphaDiversity, "processed_data/TAXA_alphadiversity.tsv")

AlphaDiversity %>%
  pivot_longer(!SampleID, names_to = "Metric", values_to = "Diversity") %>%
  left_join(metadata) %>%
  ggplot(aes(x=Group, y=Diversity, fill=Group)) +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(height=0, width=0.2, shape=21) +
  facet_wrap(~Metric, scales="free")
ggsave("figures/TAXA_alphadiversity.pdf", height=7.5, width=10, useDingbats=F)

AlphaDiversity %>%
  pivot_longer(!SampleID, names_to = "Metric", values_to = "Diversity") %>%
  left_join(metadata) %>%
  group_by(Metric) %>%
  do(
    t.test(Diversity~Group, data=.) %>%
      broom::tidy()
  ) %>%
  interactive_table()
```

### Taxa Ordination

```{r}
TaxTable<-
  Taxa %>%
  ungroup() %>%
  filter(TaxLevel=="Species") %>%
  dplyr::select(SampleID, Taxon, Relative_Abundance) %>%
  pivot_wider(names_from = "SampleID", values_from = "Relative_Abundance", values_fill = 0) %>%
  column_to_rownames("Taxon")

TaxDists<-vegan::vegdist(t(TaxTable), method="bray")
TaxPC<-ape::pcoa(TaxDists)

TaxPC$vectors %>%
  as.data.frame() %>%
  rownames_to_column("SampleID") %>%
  left_join(metadata) %>%
  ggplot(aes(x=Axis.1, y=Axis.2, fill=Group, color=Group, label=SampleID)) +
  geom_point(shape=21) +
  ggrepel::geom_text_repel(size=3) +
  xlab(paste0("PC1:", round(TaxPC$values$Rel_corr_eig[1]*100, 2), "%")) +
  ylab(paste0("PC2:", round(TaxPC$values$Rel_corr_eig[2]*100, 2), "%"))

ggsave("figures/TAXA_brayPCoA.pdf", height=7.5, width=10, useDingbats=F)

adonis2(TaxDists~Group, data=metadata[match(labels(TaxDists), metadata$SampleID),]) %>%
  print()
```


### Taxa Differential Abundance Analysis

```{r}
TaxTable<-
  Taxa %>%
  ungroup() %>%
  filter(TaxLevel=="Species") %>%
  dplyr::select(SampleID, Taxon, Relative_Abundance) %>%
  pivot_wider(names_from = "SampleID", values_from = "Relative_Abundance", values_fill = 0) %>%
  pivot_longer(!Taxon, names_to = "SampleID") %>%
  group_by(Taxon) %>%
  mutate(log2Abundance=log2(value+(2/3*(min_nonzero(value))))) #do log2 of percent abundance after filling in at 2/3 of lowest detectable value

DiffTaxa<-
  TaxTable %>%
  left_join(metadata) %>%
  DoParallel_ttest(., 4, "Taxon", "Group", "log2Abundance")

DiffTaxa %>%
  interactive_table()

write_tsv(DiffTaxa, "processed_data/TAXA_diffabundance.tsv")

DiffTaxa %>%
  mutate(Significant=if_else(FDR<0.1, "*","ns")) %>%
  mutate(Label=if_else(Significant=="*", gsub("..+\\|","", Taxon), "")) %>%
  ggplot(aes(x=log2FC, y=-log10(Pvalue), color=Significant, label=Label)) +
  geom_point(shape=16, alpha=0.7) +
  ggrepel::geom_text_repel(size=3) +
  scale_color_manual(values=c("indianred","grey70")) 

ggsave("figures/TAXA_volcano.pdf", height=7.5, width=10, useDingbats=F)
```


***

## PATHWAYS

### Pathway Composition

```{r}
Pathway_filled<-
  PathwayAbundances %>% 
  filter(Type=="Unstratified") %>%
  dplyr::select(SampleID, Pathway, Relative_Abundance) %>%
  pivot_wider(names_from = Pathway, values_from = Relative_Abundance, values_fill = 0) %>%
  column_to_rownames("SampleID") %>%
  t()

Pathway_filled %>%
  taxa_heatmap(., metadata = metadata, "Group")
ggsave("figures/PATHWAY_heatmap.pdf", height=7.5, width=10, useDingbats=F)
```

### Pathway Ordination

```{r}
TaxPC<-ape::pcoa(vegan::vegdist(t(Pathway_filled), method = "bray", ))

TaxPC$vectors %>%
  as.data.frame() %>%
  rownames_to_column("SampleID") %>%
  left_join(metadata) %>%
  ggplot(aes(x=Axis.1, y=Axis.2, fill=Group, label=SampleID, color=Group)) +
  geom_point(shape=21) +
  ggrepel::geom_text_repel(size=3) +
  xlab(paste0("PC1:", round(TaxPC$values$Rel_corr_eig[1]*100, 2), "%")) +
  ylab(paste0("PC2:", round(TaxPC$values$Rel_corr_eig[2]*100, 2), "%"))

ggsave("figures/PATHWAY_brayPCoA.pdf", height=7.5, width=10, useDingbats=F)

adonis2(TaxDists~Group, data=metadata[match(labels(TaxDists), metadata$SampleID),]) %>%
  print()
```

### Pathway Differential Abundance

```{r}
PathTable<-
  Pathway_filled %>%
  as.data.frame() %>%
  rownames_to_column("Pathway") %>%
  pivot_longer(!Pathway, names_to = "SampleID") %>%
  group_by(Pathway) %>%
  mutate(log2Abundance=log2(value+(2/3*(min_nonzero(value))))) #do log2 of percent abundance after filling in at 2/3 of lowest detectable value

DiffPath<-
  PathTable %>%
  left_join(metadata) %>%
  DoParallel_ttest(., 4, "Pathway","Group","log2Abundance")

DiffPath %>%
  interactive_table()

write_tsv(DiffPath,"processed_data/PATHWAY_diffabundance.tsv")

DiffPath %>%
  mutate(Significant=if_else(FDR<0.1, "*","ns")) %>%
  mutate(Label=if_else(Significant=="*", Pathway, "")) %>%
  ggplot(aes(x=log2FC, y=-log10(Pvalue), color=Significant, label=Label)) +
  geom_point(shape=16, alpha=0.7) +
  ggrepel::geom_text_repel(size=3) +
  scale_color_manual(values=c("indianred","grey70")) 

ggsave("figures/PATHWAY_Volcano.pdf", height=7.5, width=10, useDingbats=F)
```

***


## GENES

```{r}
GeneAbundances_filled<-
  GeneAbundances %>% 
  filter(Type=="Unstratified" & GeneFamily!="UNMAPPED") %>%
  dplyr::select(SampleID, GeneFamily, RPKG) %>%
  pivot_wider(names_from = "SampleID", values_from = "RPKG", values_fill = 0) %>%
  pivot_longer(!GeneFamily, names_to = "SampleID", values_to="RPKG") %>%
  group_by(GeneFamily) %>%
  mutate(log2RPKG=log2(RPKG+(2/3*(min_nonzero(RPKG))))) %>%
  ungroup()
```


### Gene Diversity

```{r}
Gene_Shannon<-
  GeneAbundances_filled %>%
  dplyr::select(SampleID, GeneFamily, RPKG) %>%
  pivot_wider(names_from = SampleID, values_from = RPKG) %>%
  column_to_rownames("GeneFamily") %>%
  diversity(index="shannon", MARGIN=2)

Gene_Richness<-
  GeneAbundances_filled %>%
  dplyr::select(SampleID, GeneFamily, RPKG) %>%
  pivot_wider(names_from = SampleID, values_from = RPKG) %>%
  column_to_rownames("GeneFamily") %>%
  specnumber(MARGIN=2)

Gene_Diversity<-full_join(
  data.frame(Gene_Shannon) %>% rownames_to_column("SampleID"),
  data.frame(Gene_Richness) %>% rownames_to_column("SampleID")
)

interactive_table(Gene_Diversity)

write_tsv(Gene_Diversity, "processed_data/GENE_alphadiversity.tsv")

Gene_Diversity %>%
  pivot_longer(!SampleID, names_to = "Metric", values_to = "Diversity") %>%
  left_join(metadata) %>%
  ggplot(aes(x=Group, y=Diversity, fill=Group)) +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(height=0, width=0.2, shape=21) +
  facet_wrap(~Metric, scales="free")
ggsave("figures/GENE_alphadiversity.pdf", height=7.5, width=10, useDingbats=F)

Gene_Diversity %>%
  pivot_longer(!SampleID, names_to = "Metric", values_to = "Diversity") %>%
  left_join(metadata) %>%
  group_by(Metric) %>%
  do(
    t.test(Diversity~Group, data=.) %>%
      broom::tidy()
  ) %>%
  interactive_table()
```

### Gene Ordination

```{r}
GeneDist<-
  GeneAbundances_filled %>%
  dplyr::select(SampleID, GeneFamily, RPKG) %>%
  pivot_wider(names_from = SampleID, values_from = RPKG) %>%
  column_to_rownames("GeneFamily") %>%
  t() %>%
  vegdist(., method="bray")

TaxPC<-ape::pcoa(GeneDist)

TaxPC$vectors %>%
  as.data.frame() %>%
  rownames_to_column("SampleID") %>%
  left_join(metadata) %>%
  ggplot(aes(x=Axis.1, y=Axis.2, fill=Group, label=SampleID, color=Group)) +
  geom_point(shape=21) +
  ggrepel::geom_text_repel(size=3) +
  xlab(paste0("PC1:", round(TaxPC$values$Rel_corr_eig[1]*100, 2), "%")) +
  ylab(paste0("PC2:", round(TaxPC$values$Rel_corr_eig[2]*100, 2), "%"))

ggsave("figures/GENE_brayPCoA.pdf", height=7.5, width=10, useDingbats=F)
```

### Gene Differential Abundance

```{r, eval=TRUE}
Gene_differential<-
  GeneAbundances_filled %>%
  #filter(GeneFamily %in% sample(unique(GeneFamily), 1000)) %>% # for testing on small subset
  left_join(metadata) %>%
  DoParallel_ttest(., 10, "GeneFamily","Group","log2RPKG")

#interactive_table(Gene_differential) #too large, only display significant differences
write_tsv(Gene_differential, "processed_data/GENE_diffabundance.tsv")

Gene_differential %>% filter(FDR<0.1) %>% interactive_table()
```

Note the following code will not be executed by default as rendering the image is very intensive

```{r eval=F}
Gene_differential %>%
  mutate(Significant=if_else(FDR<0.1, "*","ns")) %>%
  mutate(Label=if_else(Significant=="*", GeneFamily, "")) %>%
  ggplot(aes(x=log2FC, y=-log10(Pvalue), color=Significant, label=GeneFamily)) +
  geom_point(shape=16, alpha=0.7) +
  ggrepel::geom_text_repel(size=3) +
  scale_color_manual(values=c("indianred","grey70")) 

ggsave("figures/GENE_volcano.png", height=7.5, width=10, useDingbats=F) #note this is a png due not wanting to plot hundreds of thousands of not significant points
```
